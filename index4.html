<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Exercice 4</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <!-- Supprimer le grabbable natif (on utilise super-hands) -->
    <script>
      if (AFRAME.components && AFRAME.components['grabbable']) {
        delete AFRAME.components['grabbable'];
      }
    </script>

    <!-- aframe-extras (sphere-collider) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

    <!-- Physics system (CANNON) -->
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

    <!-- super-hands -->
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

    <style> body{margin:0} </style>

    <script>
      /* === Déplacements === */
      AFRAME.registerComponent('joystick-movement', {
        schema: { speed: { type: 'number', default: 2 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const head = document.querySelector('#head');
          const leftHand = document.querySelector('#leftHand');
          const speed = this.data.speed;
          const DEADZONE = 0.1;
          if (!leftHand) return;

          leftHand.addEventListener('thumbstickmoved', function (evt) {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            const step = 0.05 * speed;
            const rigPos = rig.object3D.position;
            rigPos.addScaledVector(forward, dy * step);
            rigPos.addScaledVector(right,  dx * step);
          });
        }
      });

      AFRAME.registerComponent('snap-turn', {
        schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const rightHand = document.querySelector('#rightHand');
          const angle = this.data.angle, cooldown = this.data.cooldown;
          let lastTurn = 0;
          if (!rightHand) return;

          rightHand.addEventListener('thumbstickmoved', function (evt) {
            const now = Date.now(), x = evt.detail.x;
            if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
            const rad = THREE.MathUtils.degToRad(angle);
            if (x > 0.8)  rig.object3D.rotation.y -= rad;
            else          rig.object3D.rotation.y += rad;
            lastTurn = now;
          });
        }
      });

      /* === Toggle-hold (aligné sur #grip) === */
      AFRAME.registerComponent('toggle-hold', {
        schema: {
          position: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
          rotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
          grip:     { type: 'selector', default: null },
          hideHand: { type: 'boolean', default: true }
        },
        init: function () {
          this._held = false;
          this._handEl = null;
          this._savedDynamic = null;
          this._onGrabStart = this._onGrabStart.bind(this);
          this._onGripDown  = this._onGripDown.bind(this);
          this.el.addEventListener('grab-start', this._onGrabStart);
        },
        _onGrabStart: function (evt) {
          if (this._held) return;
          const hand = evt.detail && evt.detail.hand;
          if (!hand) return;

          if (this.el.hasAttribute('dynamic-body')) {
            this._savedDynamic = this.el.getAttribute('dynamic-body');
            this.el.removeAttribute('dynamic-body');
          }

          hand.object3D.attach(this.el.object3D);

          const rot = this.data.rotation;
          this.el.object3D.rotation.set(
            THREE.MathUtils.degToRad(rot.x),
            THREE.MathUtils.degToRad(rot.y),
            THREE.MathUtils.degToRad(rot.z)
          );

          const gripEl = this.data.grip;
          if (gripEl && gripEl.object3D) {
            const gripWorld = new THREE.Vector3();
            gripEl.object3D.updateWorldMatrix(true, true);
            gripEl.object3D.getWorldPosition(gripWorld);
            const gripLocalInHand = gripWorld.clone();
            hand.object3D.worldToLocal(gripLocalInHand);
            this.el.object3D.position.sub(gripLocalInHand);
          }

          const pos = this.data.position;
          this.el.object3D.position.add(new THREE.Vector3(pos.x, pos.y, pos.z));

          if (this.data.hideHand) {
            try { hand.style.display = 'none'; } catch(e) { hand.setAttribute('visible', 'false'); }
          }

          this._held = true;
          this._handEl = hand;
          this.el.emit('hold-start', { hand });
          hand.addEventListener('gripdown', this._onGripDown);
        },
        _onGripDown: function () {
          if (!this._held || !this._handEl) return;
          this._handEl.sceneEl.object3D.attach(this.el.object3D);

          if (this._savedDynamic) {
            this.el.setAttribute('dynamic-body', this._savedDynamic);
            this._savedDynamic = null;
          }

          if (this.data.hideHand) {
            try { this._handEl.style.display = ''; } catch(e) { this._handEl.setAttribute('visible', 'true'); }
          }

          this.el.emit('hold-end', { hand: this._handEl });
          this._handEl.removeEventListener('gripdown', this._onGripDown);
          this._held = false;
          this._handEl = null;
        }
      });

      /* === Particules simples === */
      function spawnParticles(sceneEl, worldPos, count = 12, life = 500) {
        for (let i = 0; i < count; i++) {
          const p = document.createElement('a-sphere');
          p.setAttribute('radius', 0.02);
          const colors = ['#FFD322', '#FF8A00', '#FF3B30'];
          p.setAttribute('color', colors[Math.floor(Math.random()*colors.length)]);
          p.setAttribute('material', 'opacity:1; transparent:true');
          p.setAttribute('position', `${worldPos.x} ${worldPos.y} ${worldPos.z}`);

          const dx = (Math.random() - 0.5) * 0.8;
          const dy = Math.random() * 0.8;
          const dz = (Math.random() - 0.5) * 0.8;

          p.setAttribute('animation__move', `property: position; to: ${worldPos.x+dx} ${worldPos.y+dy} ${worldPos.z+dz}; dur: ${life}; easing: easeOutQuad`);
          p.setAttribute('animation__fade', `property: material.opacity; from: 1; to: 0; dur: ${life}; easing: linear`);
          sceneEl.appendChild(p);
          setTimeout(() => { if (p.parentNode) p.parentNode.removeChild(p); }, life + 60);
        }
      }

      /* === Cible : son + particules + auto-destruction (déférée) === */
      AFRAME.registerComponent('target', {
        schema: {
          hitsound: { type: 'selector' },
          particles: { type: 'int', default: 12 },
          life: { type: 'number', default: 500 }
        },
        init: function () {
          this._dead = false;
          this.el.classList.add('target');
          if (!this.el.hasAttribute('static-body')) this.el.setAttribute('static-body', '');
          this._onBulletHit = this._onBulletHit.bind(this);
          this.el.addEventListener('bullet-hit', this._onBulletHit);
        },
        remove: function () {
          this.el.removeEventListener('bullet-hit', this._onBulletHit);
        },
        _onBulletHit: function (evt) {
          if (this._dead) return;
          this._dead = true;

          const scene = this.el.sceneEl;
          const pos = new THREE.Vector3();
          if (evt.detail && evt.detail.worldPos) pos.copy(evt.detail.worldPos);
          else this.el.object3D.getWorldPosition(pos);

          if (this.data.hitsound) {
            const s = document.createElement('a-entity');
            s.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            s.setAttribute('sound',
              `src: #${this.data.hitsound.id}; autoplay: true; positional: true; 
               volume: 0.7; refDistance: 1.2; rolloffFactor: 2.0; distanceModel: inverse`);
            scene.appendChild(s);
            setTimeout(() => { if (s.parentNode) s.parentNode.removeChild(s); }, 1500);
          }

          spawnParticles(scene, pos, this.data.particles, this.data.life);

          // Notifier le spawner tout de suite (il attendra respawnDelay)
          scene.emit('target-destroyed', { el: this.el });

          // --- RENDRE INERTE + SUPPRIMER DANS LA FRAME SUIVANTE ---
          try {
            const body = this.el.body || (this.el.components['static-body'] && this.el.components['static-body'].body);
            if (body) { body.collisionResponse = false; body.collisionFilterMask = 0; } // FIX: couper les collisions
          } catch (e) { /* noop */ }
          this.el.setAttribute('visible', 'false'); // FIX: cacher tout de suite

          requestAnimationFrame(() => { // FIX: différer la suppression hors du step() physique
            if (this.el.hasAttribute('static-body')) this.el.removeAttribute('static-body'); // FIX: détacher du monde Cannon proprement
            if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
          });
        }
      });

      /* === Flottement style AimLab === */
      AFRAME.registerComponent('hover-bob', {
        schema: {
          amp:   { type: 'number', default: 0.18 },
          speed: { type: 'number', default: 0.5 },
          phase: { type: 'number', default: 0 }
        },
        init: function(){ this.baseY = this.el.object3D.position.y; },
        tick: function (t) {
          const time = t/1000;
          this.el.object3D.position.y = this.baseY + this.data.amp * Math.sin((time + this.data.phase) * this.data.speed * 2*Math.PI);
        }
      });

      /* === Spawner de cibles aériennes === */
      AFRAME.registerComponent('target-spawner', {
        schema: {
          areaMin: { type: 'vec3', default: { x: -3, y: 1.2, z: -6 } },
          areaMax: { type: 'vec3', default: { x:  3, y: 2.2, z: -2 } },
          maxTargets: { type: 'int', default: 6 },
          respawnDelay: { type: 'number', default: 1000 },
          shapes: { type: 'string', default: 'box,sphere' },
          minPlayerDist: { type: 'number', default: 1.6 }
        },
        init: function () {
          this._targets = new Set();
          this._onDestroyed = this._onDestroyed.bind(this);
          this.rig = document.querySelector('#rig');
          this.el.sceneEl.addEventListener('target-destroyed', this._onDestroyed);
          this._fill();
        },
        remove: function () {
          this.el.sceneEl.removeEventListener('target-destroyed', this._onDestroyed);
        },
        _randBetween(min, max) { return min + Math.random() * (max - min); },
        _randomPos: function () {
          const a = this.data.areaMin, b = this.data.areaMax;
          return { x: this._randBetween(a.x, b.x), y: this._randBetween(a.y, b.y), z: this._randBetween(a.z, b.z) };
        },
        _spawnOne: function () {
          const scene = this.el.sceneEl;
          const shapes = this.data.shapes.split(',').map(s => s.trim());
          const shape = shapes[Math.floor(Math.random() * shapes.length)];

          let t;
          switch (shape) {
            case 'sphere':   t = document.createElement('a-sphere');   t.setAttribute('radius','0.28'); break;
            default:         t = document.createElement('a-box');      t.setAttribute('depth','0.25');  t.setAttribute('height','0.25'); t.setAttribute('width','0.25');
          }

          let pos, ok=false, tries=0;
          while (!ok && tries < 15) {
            pos = this._randomPos(); tries++;
            if (!this.rig) { ok = true; break; }
            const rp = this.rig.object3D.position;
            const dx=pos.x - rp.x, dy=pos.y - (rp.y+1.3), dz=pos.z - rp.z;
            const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
            ok = dist >= this.data.minPlayerDist;
          }

          const hue = Math.floor(Math.random()*360);
          t.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
          t.setAttribute('rotation', `0 ${Math.floor(Math.random()*360)} 0`);
          t.setAttribute('color', `hsl(${hue}, 70%, 55%)`);
          t.setAttribute('shadow', 'cast:true; receive:true');
          t.setAttribute('target', 'hitsound: #hitSfx; particles: 16; life: 550');
          t.setAttribute('static-body', '');
          t.setAttribute('hover-bob', `amp: ${0.14 + Math.random()*0.12}; speed: ${0.45 + Math.random()*0.25}; phase: ${Math.random()}`);

          scene.appendChild(t);
          this._targets.add(t);
        },
        _fill: function () { while (this._targets.size < this.data.maxTargets) this._spawnOne(); },
        _onDestroyed: function (e) {
          const el = e.detail && e.detail.el;
          if (el && this._targets.has(el)) {
            this._targets.delete(el);
            setTimeout(() => this._fill(), this.data.respawnDelay);
          }
        }
      });

      /* === Tir — son relançable, balle garde sa durée de vie === */
      AFRAME.registerComponent('gun-shoot', {
        schema: { speed: {type:'number', default:20}, lifetime: {type:'number', default:4000} },
        init: function () {
          this._onTriggerDown = this._onTriggerDown.bind(this);
          this._onHoldStart   = this._onHoldStart.bind(this);
          this._onHoldEnd     = this._onHoldEnd.bind(this);
          this._hand = null;

          this.muzzle = this.el.querySelector('#muzzle');
          this.shotAudioEl = this.el.querySelector('#shotAudio');

          this._playShot = () => {
            const sndNode =
              (this.shotAudioEl && this.shotAudioEl.components && this.shotAudioEl.components.sound)
              || (this.muzzle && this.muzzle.components && this.muzzle.components.sound
                  ? this.muzzle.components.sound : null);
            if (sndNode) {
              if (sndNode.isPlaying) sndNode.stopSound();
              sndNode.playSound();
            }
          };

          this.el.addEventListener('hold-start', this._onHoldStart);
          this.el.addEventListener('hold-end',   this._onHoldEnd);
        },
        remove: function () {
          this.el.removeEventListener('hold-start', this._onHoldStart);
          this.el.removeEventListener('hold-end',   this._onHoldEnd);
          if (this._hand) {
            this._hand.removeEventListener('triggerdown', this._onTriggerDown);
            this._hand = null;
          }
        },
        _onHoldStart: function (evt) {
          const hand = evt.detail && evt.detail.hand;
          if (!hand) return;
          this._hand = hand;
          hand.addEventListener('triggerdown', this._onTriggerDown);
        },
        _onHoldEnd: function () {
          if (this._hand) {
            this._hand.removeEventListener('triggerdown', this._onTriggerDown);
            this._hand = null;
          }
        },
        _onTriggerDown: function () {
          const hold = this.el.components['toggle-hold'];
          if (!hold || !hold._held) return;

          this._playShot();

          const muzzle = this.muzzle || this.el;
          const bullet = document.createElement('a-sphere');
          bullet.setAttribute('radius', 0.025);
          bullet.setAttribute('color', 'yellow');
          bullet.setAttribute('shadow', 'cast: true; receive: false');
          bullet.setAttribute('dynamic-body', 'mass: 0.02; shape: sphere; sphereRadius: 0.025');

          const pos = new THREE.Vector3();
          const dir = new THREE.Vector3(0, 0, -1);
          muzzle.object3D.getWorldPosition(pos);
          muzzle.object3D.getWorldDirection(dir);
          dir.normalize();
          pos.addScaledVector(dir, 0.04);

          bullet.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
          this.el.sceneEl.appendChild(bullet);

          const onCollide = (e) => {
            const other = e.detail && e.detail.body && e.detail.body.el;
            if (other && other.components && other.components['target']) {
              const p = new THREE.Vector3();
              bullet.object3D.getWorldPosition(p);
              other.emit('bullet-hit', { worldPos: p });
            }
            // Rendre la balle inerte (pas de re-triggers), la laisser vivre jusqu'au timeout
            try {
              const body = bullet.body || (bullet.components['dynamic-body'] && bullet.components['dynamic-body'].body);
              if (body) { body.collisionResponse = false; body.collisionFilterMask = 0; }
            } catch (err) {}
            bullet.removeEventListener('collide', onCollide);
          };
          bullet.addEventListener('collide', onCollide);

          const speed = this.data.speed;
          bullet.addEventListener('body-loaded', () => {
            bullet.setAttribute('velocity', `${dir.x * speed} ${dir.y * speed} ${dir.z * speed}`);
          });

          setTimeout(() => { if (bullet.parentNode) bullet.parentNode.removeChild(bullet); }, this.data.lifetime);
        }
      });
    </script>
  </head>

  <body>
    <a href="index.html" style="
        position: fixed;
        top: 15px;
        left: 15px;
        background: rgba(255,255,255,0.9);
        color: #000;
        text-decoration: none;
        padding: 8px 14px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 9999;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        ">⬅ Retour accueil
    </a>
    <a-scene
      shadow="type: pcfsoft"
      renderer="antialias: true"
      vr-mode-ui="enabled: true"
      device-orientation-permission-ui="enabled: true"
      physics="gravity: -9.8; debug: false"
    >
      <!-- Assets -->
      <a-assets>
        <img id="skyTexture" src="./assets/skynet.jpg" />
        <img id="groundTexture" src="./assets/grass.jpg" />
        <a-asset-item id="gunModel" src="./assets/scene.gltf"></a-asset-item>

        <!-- Sons -->
        <audio id="hitSfx"  src="./assets/hit.mp3"  preload="auto"></audio>
        <audio id="shotSfx" src="./assets/shot.mp3" preload="auto"></audio>
      </a-assets>

      <!-- Lumières -->
      <a-entity light="type: ambient; intensity: 0.4"></a-entity>
      <a-entity light="type: directional; intensity: 1; castShadow: true" position="2 4 -2"></a-entity>

      <!-- RIG + caméra + contrôleurs -->
      <a-entity id="rig" position="0 1 0" joystick-movement="speed: 2" snap-turn="angle: 30; cooldown: 300">
        <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

        <a-entity id="leftHand"
          oculus-touch-controls="hand: left"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>

        <a-entity id="rightHand"
          oculus-touch-controls="hand: right"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>
      </a-entity>

      <!-- Objets grabbables (physiques) -->
      <a-box class="grabbable" position="-1 0.6 -1.6" rotation="0 45 0" color="#4CC3D9"
             shadow="cast: true; receive: true"
             grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
             dynamic-body="mass: 1; shape: box"></a-box>

      <a-sphere class="grabbable" position="0 1.2 -2" radius="0.5" color="#EF2D5E"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                dynamic-body="mass: 0.5; shape: sphere"></a-sphere>

      <a-cylinder class="grabbable" position="1 0.9 -2.4" radius="0.4" height="1" color="#FFC65D"
                  shadow="cast: true; receive: true"
                  grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                  dynamic-body="mass: 0.75; shape: cylinder"></a-cylinder>

      <!-- Table -->
      <a-box position="2.5 0.75 -1" width="1" height="0.1" depth="1" color="#8B4513"
             shadow="cast: true; receive: true" static-body></a-box>

      <!-- === ARME === -->
      <a-entity id="gun"
        class="grabbable"
        position="2.531 1.2 -1.0"
        rotation="0 0 0"
        scale="0.1 0.1 0.1"
        shadow="cast: true; receive: true"
        gltf-model="#gunModel"
        dynamic-body="mass: 1; shape: box"
        grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
        toggle-hold="rotation: 30 90 -60; grip: #grip; hideHand: true"
        gun-shoot="speed: 20; lifetime: 4000">

        <a-entity id="grip"   position="-1.485 -0.437 -0.02"></a-entity>
        <a-entity id="muzzle" position="0.50 0.417 -0.015" rotation="0 90 0">
          <a-entity id="shotAudio"
            sound="src: #shotSfx; autoplay: false; positional: true;
                   volume: 0.8; refDistance: 1.2; rolloffFactor: 1.6; distanceModel: inverse">
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Sol -->
      <a-plane position="0 0 -1" rotation="-90 0 0" width="100" height="100" src="#groundTexture"
               shadow="cast: false; receive: true" static-body></a-plane>

      <!-- Spawner de cibles aériennes -->
      <a-entity id="targetSpawner"
        target-spawner="
          areaMin: -3 1.2 -6;
          areaMax:  3 2.2 -2;
          maxTargets: 6;
          respawnDelay: 1000;
          shapes: box,sphere;
          minPlayerDist: 1.6">
      </a-entity>

      <a-sky src="#skyTexture"></a-sky>
    </a-scene>
  </body>
</html>
