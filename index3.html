<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Exercice 3 – Wrapper physique + Grab fluide + Tir aligné</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <!-- Supprimer le grabbable natif (on utilise super-hands) -->
    <script>
      if (AFRAME.components && AFRAME.components['grabbable']) {
        delete AFRAME.components['grabbable'];
      }
    </script>

    <!-- aframe-extras (sphere-collider) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

    <!-- Physics system (CANNON) -->
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

    <!-- super-hands -->
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

    <style> body{margin:0} </style>

    <script>
      /* === Déplacements (ton code) === */
      AFRAME.registerComponent('joystick-movement', {
        schema: { speed: { type: 'number', default: 2 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const head = document.querySelector('#head');
          const leftHand = document.querySelector('#leftHand');
          const speed = this.data.speed;
          const DEADZONE = 0.1;
          if (!leftHand) return;

          leftHand.addEventListener('thumbstickmoved', function (evt) {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            const step = 0.05 * speed;
            const rigPos = rig.object3D.position;
            rigPos.addScaledVector(forward, dy * step);
            rigPos.addScaledVector(right,  dx * step);
          });
        }
      });

      AFRAME.registerComponent('snap-turn', {
        schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const rightHand = document.querySelector('#rightHand');
          const angle = this.data.angle, cooldown = this.data.cooldown;
          let lastTurn = 0;
          if (!rightHand) return;

          rightHand.addEventListener('thumbstickmoved', function (evt) {
            const now = Date.now(), x = evt.detail.x;
            if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
            const rad = THREE.MathUtils.degToRad(angle);
            if (x > 0.8)  rig.object3D.rotation.y -= rad;
            else          rig.object3D.rotation.y += rad;
            lastTurn = now;
          });
        }
      });

      /* === Toggle-hold : grab fluide (désactive-physique pendant le hold) ===
         - Wrapper physique (invisible) conserve la gravité quand posé
         - Au grab : on remove dynamic-body TEMPORAIREMENT, on attache à la main
         - À la relâche : on réattache à la scène et on RESTAURE dynamic-body
      */
      AFRAME.registerComponent('toggle-hold', {
        schema: {
          position: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }, // offset dans la main
          rotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }       // orientation ergonomique
        },
        init: function () {
          this._held = false;
          this._handEl = null;
          this._savedDynamic = null;

          this._onGrabStart = this._onGrabStart.bind(this);
          this._onGripDown = this._onGripDown.bind(this);

          this.el.addEventListener('grab-start', this._onGrabStart);
        },
        _onGrabStart: function (evt) {
          if (this._held) return;
          const hand = evt.detail && evt.detail.hand;
          if (!hand) return;

          // Sauver + retirer la physique (anti-jitter)
          if (this.el.hasAttribute('dynamic-body')) {
            this._savedDynamic = this.el.getAttribute('dynamic-body');
            this.el.removeAttribute('dynamic-body');
          }

          // Attacher l'objet dans la main (suivi parfait)
          hand.object3D.attach(this.el.object3D);

          // Offset/rotation locaux
          const pos = this.data.position;
          this.el.object3D.position.set(pos.x, pos.y, pos.z);
          const rot = this.data.rotation;
          this.el.object3D.rotation.set(
            THREE.MathUtils.degToRad(rot.x),
            THREE.MathUtils.degToRad(rot.y),
            THREE.MathUtils.degToRad(rot.z)
          );

          // Cacher la main pendant le hold (évite chevauchement visuel)
          try { hand.style.display = 'none'; } catch(e) { hand.setAttribute('visible', 'false'); }

          this._held = true;
          this._handEl = hand;

          // relâche = gripdown
          hand.addEventListener('gripdown', this._onGripDown);
        },
        _onGripDown: function () {
          if (!this._held || !this._handEl) return;

          // Détacher vers la scène
          this._handEl.sceneEl.object3D.attach(this.el.object3D);

          // Restaurer la physique (gravité quand reposé)
          if (this._savedDynamic) {
            this.el.setAttribute('dynamic-body', this._savedDynamic);
            this._savedDynamic = null;
          }

          // Rendre la main visible
          try { this._handEl.style.display = ''; } catch(e) { this._handEl.setAttribute('visible', 'true'); }

          this._handEl.removeEventListener('gripdown', this._onGripDown);
          this._held = false;
          this._handEl = null;
        }
      });

      /* === Tir (depuis #muzzle, direction = getWorldDirection) === */
      AFRAME.registerComponent('gun-shoot', {
        schema: {
          speed: { type: 'number', default: 55 },
          lifetime: { type: 'number', default: 4000 }
        },
        init: function () {
          this._onTriggerDown = this._onTriggerDown.bind(this);
          // On met #muzzle sur l'enfant visuel (le modèle), mais le composant est sur le WRAPPER
          this.muzzle = this.el.querySelector('#muzzle');

          // Abonnement au trigger uniquement quand l'arme est tenue
          this.el.addEventListener('grab-start', evt => {
            const hand = evt.detail && evt.detail.hand;
            if (hand) hand.addEventListener('triggerdown', this._onTriggerDown);
          });
          this.el.addEventListener('grab-end', evt => {
            const hand = evt.detail && evt.detail.hand;
            if (hand) hand.removeEventListener('triggerdown', this._onTriggerDown);
          });
        },
        _onTriggerDown: function () {
          const hold = this.el.components['toggle-hold'];
          if (!hold || !hold._held) return;

          const muzzle = this.muzzle || this.el; // fallback
          const bullet = document.createElement('a-sphere');
          bullet.setAttribute('radius', 0.025);
          bullet.setAttribute('color', 'yellow');
          bullet.setAttribute('shadow', 'cast: true; receive: false');
          // petit rayon pour réduire les collisions immédiates, masse faible
          bullet.setAttribute('dynamic-body', 'mass: 0.02; shape: sphere; sphereRadius: 0.025');

          // Position monde du muzzle + petit offset vers l'avant pour éviter collision avec le gun
          const pos = new THREE.Vector3();
          const dir = new THREE.Vector3(0, 0, 0);
          muzzle.object3D.getWorldPosition(pos);
          muzzle.object3D.getWorldDirection(dir);
          dir.normalize();
          const offset = 0; // 5 cm devant le canon
          pos.addScaledVector(dir, offset);

          bullet.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
          this.el.sceneEl.appendChild(bullet);

          // Appliquer vitesse quand le body est prêt
          const speed = this.data.speed;
          bullet.addEventListener('body-loaded', () => {
            bullet.setAttribute('velocity', `${dir.x * speed} ${dir.y * speed} ${dir.z * speed}`);
          });

          // Nettoyage auto
          setTimeout(() => {
            if (bullet.parentNode) bullet.parentNode.removeChild(bullet);
          }, this.data.lifetime);
        }
      });
    </script>
  </head>

  <body>
    <a-scene
      shadow="type: pcfsoft"
      renderer="antialias: true"
      vr-mode-ui="enabled: true"
      device-orientation-permission-ui="enabled: true"
      physics="gravity: -9.8; debug: false"
    >
      <!-- Assets -->
      <a-assets>
        <img id="skyTexture" src="./skynet.jpg" />
        <img id="groundTexture" src="./grass.jpg" />
        <!-- Ton modèle GLTF (avec scene.bin dans le même dossier) -->
        <a-asset-item id="gunModel" src="./assets/scene.gltf"></a-asset-item>
      </a-assets>

      <!-- Lumières -->
      <a-entity light="type: ambient; intensity: 0.4"></a-entity>
      <a-entity light="type: directional; intensity: 1; castShadow: true" position="2 4 -2"></a-entity>

      <!-- RIG + caméra + contrôleurs -->
      <a-entity id="rig" position="0 1 0" joystick-movement="speed: 2" snap-turn="angle: 30; cooldown: 300">
        <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

        <a-entity id="leftHand"
          oculus-touch-controls="hand: left"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>

        <a-entity id="rightHand"
          oculus-touch-controls="hand: right"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>
      </a-entity>

      <!-- Objets grabbables (physiques) -->
      <a-box class="grabbable" position="-1 0.6 -1.6" rotation="0 45 0" color="#4CC3D9"
             shadow="cast: true; receive: true"
             grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
             dynamic-body="mass: 1; shape: box"></a-box>

      <a-sphere class="grabbable" position="0 1.2 -2" radius="0.5" color="#EF2D5E"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                dynamic-body="mass: 0.5; shape: sphere"></a-sphere>

      <a-cylinder class="grabbable" position="1 0.9 -2.4" radius="0.4" height="1" color="#FFC65D"
                  shadow="cast: true; receive: true"
                  grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                  dynamic-body="mass: 0.75; shape: cylinder"></a-cylinder>

      <!-- Table -->
      <a-box position="2.5 0.75 -1" width="1" height="0.1" depth="1" color="#8B4513"
             shadow="cast: true; receive: true" static-body></a-box>

      <!-- === GUN ===
           Wrapper invisible = physique + grab
           Enfant = modèle (visuel) + #muzzle pour le tir
      -->
        <!-- Modèle visuel du pistolet -->
        <a-entity id="gunVisual"
          class="grabbable"
          gltf-model="#gunModel"
          scale="0.1 0.1 0.1"
          rotation="0 90 0"
          shadow="cast: true; receive: true"
          position="2.531 1.2 -1.0"
          shadow="cast: true; receive: true"
          material="opacity: 0; transparent: true"
          dynamic-body="mass: 1; shape: box"
          grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
          toggle-hold="position: 0 -0.1 -0.2; rotation: 30 90 -60"
          gun-shoot="speed: 55; lifetime: 4000">
          <!-- Muzzle : ajuste la position/rotation pour qu'il soit précisément au bout du canon -->
          <a-entity id="muzzle" position="2.185 0.417 -0.015" rotation="0 -90 0" material="box" opacity="1"></a-entity>
        </a-entity>
      </a-entity>

      <!-- Sol -->
      <a-plane position="0 0 -1" rotation="-90 0 0" width="100" height="100" src="#groundTexture"
               shadow="cast: false; receive: true" static-body></a-plane>

      <a-sky src="#skyTexture"></a-sky>
    </a-scene>
  </body>
</html>
